<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DFSearch.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">minicp:minicp</a> &gt; <a href="index.source.html" class="el_package">minicp.search</a> &gt; <span class="el_source">DFSearch.java</span></div><h1>DFSearch.java</h1><pre class="source lang-java linenums">/*
 * mini-cp is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License  v3
 * as published by the Free Software Foundation.
 *
 * mini-cp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY.
 * See the GNU Lesser General Public License  for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with mini-cp. If not, see http://www.gnu.org/licenses/lgpl-3.0.en.html
 *
 * Copyright (c)  2018. by Laurent Michel, Pierre Schaus, Pascal Van Hentenryck
 */

package minicp.search;

import minicp.state.StateManager;
import minicp.util.exception.InconsistencyException;
import minicp.util.exception.NotImplementedException;
import minicp.util.Procedure;

import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Predicate;
import java.util.function.Supplier;

/**
 * Depth First Search Branch and Bound implementation
 */
public class DFSearch {

    private Supplier&lt;Procedure[]&gt; branching;
    private StateManager sm;


<span class="fc" id="L38">    private List&lt;DFSListener&gt; dfsListeners = new LinkedList&lt;DFSListener&gt;();</span>


    private int currNodeIdId;

    /**
     * Creates a Depth First Search object with a given branching
     * that defines the search tree dynamically.
     *
     * @param sm the state manager that will be saved and restored
     *           at each node of the search tree
     * @param branching a generator of closures in charge of defining the ordered
     *                  children nodes at each node of the depth-first-search tree.
     *                  When it returns an empty array, a solution is found.
     *                  A backtrack occurs when a {@link InconsistencyException}
     *                  is thrown.
     */
<span class="fc" id="L55">    public DFSearch(StateManager sm, Supplier&lt;Procedure[]&gt; branching) {</span>
<span class="fc" id="L56">        this.sm = sm;</span>
<span class="fc" id="L57">        this.branching = branching;</span>
<span class="fc" id="L58">    }</span>

    /**
     * Adds a listener that is called on each solution.
     *
     * @param listener the closure to be called whenever a solution is found
     */
    public void onSolution(Procedure listener) {
<span class="fc" id="L66">        dfsListeners.add(new DFSListener() {</span>
            @Override
            public void solution(int pId, int id, int position) {
<span class="fc" id="L69">                listener.call();</span>
<span class="fc" id="L70">            }</span>
        });
<span class="fc" id="L72">    }</span>


    public void addListener(DFSListener listener) {
<span class="nc" id="L76">        dfsListeners.add(listener);</span>
<span class="nc" id="L77">    }</span>

    /**
     * Adds a listener that is called whenever a failure occurs
     * and the search backtracks.
     * This happensthat when a {@link InconsistencyException} is thrown
     * when executing the closure generated by the branching.
     *
     * @param listener the closure to be called whenever a failure occurs and
     *                 the search need to backtrack
     */
    public void onFailure(Procedure listener) {
<span class="nc" id="L89">        dfsListeners.add(new DFSListener() {</span>
            @Override
            public void fail(int pId, int id, int position) {
<span class="nc" id="L92">                listener.call();</span>
<span class="nc" id="L93">            }</span>
        });
<span class="nc" id="L95">    }</span>


    private void notifySolution(int parentId, int nodeId, int position) {
<span class="fc" id="L99">        dfsListeners.forEach(l -&gt; l.solution(parentId, nodeId, position));</span>
<span class="fc" id="L100">    }</span>

    private void notifyFailure(int parentId, int nodeId, int position) {
<span class="pc" id="L103">        dfsListeners.forEach(l -&gt; l.fail(parentId, nodeId, position));</span>
<span class="fc" id="L104">    }</span>

    private void notifyBranch(int parentId, int nodeId, int position, int nChilds) {
<span class="fc" id="L107">        dfsListeners.forEach(l -&gt; l.branch(parentId, nodeId, position, nChilds));</span>
<span class="fc" id="L108">    }</span>

    private SearchStatistics solve(SearchStatistics statistics, Predicate&lt;SearchStatistics&gt; limit) {
<span class="fc" id="L111">        currNodeIdId = 0;</span>
<span class="fc" id="L112">        sm.withNewState(() -&gt; {</span>
            try {
<span class="fc" id="L114">                dfs(statistics, limit , -1, -1);</span>
<span class="fc" id="L115">                statistics.setCompleted();</span>
<span class="fc" id="L116">            } catch (StopSearchException ignored) {</span>
<span class="fc" id="L117">            } catch (StackOverflowError e) {</span>
<span class="fc" id="L118">                throw new NotImplementedException(&quot;dfs with explicit stack needed to pass this test&quot;);</span>
<span class="fc" id="L119">            }</span>
<span class="fc" id="L120">        });</span>
<span class="fc" id="L121">        return statistics;</span>
    }


    /**
     * Effectively start a depth first search
     * looking for every solution.
     *
     * @return an object with the statistics on the search
     */
    public SearchStatistics solve() {
<span class="fc" id="L132">        SearchStatistics statistics = new SearchStatistics();</span>
<span class="fc" id="L133">        return solve(statistics, stats -&gt; false);</span>
    }

    /**
     * Effectively start a depth first search
     * with a given predicate called at each node
     * to stop the search when it becomes true.
     *
     * @param limit a predicate called at each node
     *             that stops the search when it becomes true
     * @return an object with the statistics on the search
     */
    public SearchStatistics solve(Predicate&lt;SearchStatistics&gt; limit) {
<span class="fc" id="L146">        SearchStatistics statistics = new SearchStatistics();</span>
<span class="fc" id="L147">        return solve(statistics, limit);</span>
    }

    /**
     * Executes a closure prior to effectively
     * starting a depth first search
     * with a given predicate called at each node
     * to stop the search when it becomes true.
     * The state manager saves the state
     * before executing the closure
     * and restores it after the search.
     * Any {@link InconsistencyException} that may
     * be throw when executing the closure is also catched.
     *
     * @param limit a predicate called at each node
     *             that stops the search when it becomes true
     * @param subjectTo the closure to execute prior to the search starts
     * @return an object with the statistics on the search
     */
    public SearchStatistics solveSubjectTo(Predicate&lt;SearchStatistics&gt; limit, Procedure subjectTo) {
<span class="fc" id="L167">        SearchStatistics statistics = new SearchStatistics();</span>
<span class="fc" id="L168">        sm.withNewState(() -&gt; {</span>
            try {
<span class="fc" id="L170">                subjectTo.call();</span>
<span class="fc" id="L171">                solve(statistics, limit);</span>
<span class="nc" id="L172">            } catch (InconsistencyException e) {</span>
<span class="fc" id="L173">            }</span>
<span class="fc" id="L174">        });</span>
<span class="fc" id="L175">        return statistics;</span>
    }

    /**
     * Effectively start a branch and bound
     * depth first search with a given objective.
     *
     * @param obj the objective to optimize that is tightened each
     *            time a new solution is found
     * @return an object with the statistics on the search
     */
    public SearchStatistics optimize(Objective obj) {
<span class="nc" id="L187">        return optimize(obj, stats -&gt; false);</span>
    }

    /**
     * Effectively start a branch and bound
     * depth first search with a given objective
     * and with a given predicate called at each node
     * to stop the search when it becomes true.
     *
     * @param obj the objective to optimize that is tightened each
     *            time a new solution is found
     * @param limit a predicate called at each node
     *             that stops the search when it becomes true
     * @return an object with the statistics on the search
     */
    public SearchStatistics optimize(Objective obj, Predicate&lt;SearchStatistics&gt; limit) {
<span class="nc" id="L203">        SearchStatistics statistics = new SearchStatistics();</span>
<span class="nc" id="L204">        onSolution(() -&gt; obj.tighten());</span>
<span class="nc" id="L205">        return solve(statistics, limit);</span>
    }

    /**
     * Executes a closure prior to effectively
     * starting a branch and bound depth first search
     * with a given objective to optimize
     * and a given predicate called at each node
     * to stop the search when it becomes true.
     * The state manager saves the state
     * before executing the closure
     * and restores it after the search.
     * Any {@link InconsistencyException} that may
     * be throw when executing the closure is also catched.
     *
     * @param obj the objective to optimize that is tightened each
     *            time a new solution is found
     * @param limit a predicate called at each node
     *             that stops the search when it becomes true
     * @param subjectTo the closure to execute prior to the search starts
     * @return an object with the statistics on the search
     */
    public SearchStatistics optimizeSubjectTo(Objective obj, Predicate&lt;SearchStatistics&gt; limit, Procedure subjectTo) {
<span class="nc" id="L228">        AtomicReference&lt;SearchStatistics&gt; statistics = new AtomicReference&lt;&gt;();</span>
<span class="nc" id="L229">        statistics.set(new SearchStatistics());</span>
<span class="nc" id="L230">        sm.withNewState(() -&gt; {</span>
            try {
<span class="nc" id="L232">                subjectTo.call();</span>
<span class="nc" id="L233">                statistics.set(optimize(obj, limit));</span>
<span class="nc" id="L234">            } catch (InconsistencyException e) {</span>
<span class="nc" id="L235">            }</span>
<span class="nc" id="L236">        });</span>
<span class="nc" id="L237">        return statistics.get();</span>
    }


    private void dfs(SearchStatistics statistics, Predicate&lt;SearchStatistics&gt; limit, int parentId, int position) {
<span class="fc bfc" id="L242" title="All 2 branches covered.">        if (limit.test(statistics))</span>
<span class="fc" id="L243">            throw new StopSearchException();</span>
<span class="fc" id="L244">        Procedure[] branches = branching.get();</span>
<span class="fc" id="L245">        final int nodeId = currNodeIdId++;</span>

<span class="fc bfc" id="L247" title="All 2 branches covered.">        if (branches.length == 0) {</span>
<span class="fc" id="L248">            statistics.incrSolutions();</span>
<span class="fc" id="L249">            notifySolution(parentId,nodeId, position);</span>
        } else {
<span class="fc" id="L251">            notifyBranch(parentId,nodeId, position, branches.length);</span>
<span class="fc" id="L252">            int pos = 0;</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">            for (Procedure b : branches) {</span>
<span class="fc" id="L254">                final int p = pos;</span>
<span class="fc" id="L255">                sm.withNewState(() -&gt; {</span>
                    try {
<span class="fc" id="L257">                        statistics.incrNodes();</span>
<span class="fc" id="L258">                        b.call();</span>
<span class="fc" id="L259">                        dfs(statistics, limit, nodeId, p);</span>
<span class="fc" id="L260">                    } catch (InconsistencyException e) {</span>
<span class="fc" id="L261">                        currNodeIdId++;</span>
<span class="fc" id="L262">                        statistics.incrFailures();</span>
<span class="fc" id="L263">                        notifyFailure(parentId,nodeId, p);</span>
<span class="fc" id="L264">                    }</span>
<span class="fc" id="L265">                });</span>
<span class="fc" id="L266">                pos += 1;</span>
            }
        }
<span class="fc" id="L269">    }</span>

    /*
    public void showTree(){
        cpprofilerbridge.Connector c = new cpprofilerbridge.Connector();
        // Connect to port 6565 (default for cp-profiler)        
        try {
            c.connect(6565);
            try {
                c.start(&quot;EXAMPLE&quot;,-1);
                while(nodelist.size() &gt; 0){
                    Node node = nodelist.get(0);
                    c.createNode(node.getid(), node.getpid(), node.getpos(), node.children.size(), node.getStatus()).setNodeLabel(&quot;node: &quot; + node.getid()).setNodeInfo(node.toString()).send();           
                    nodelist.remove(0);
                }
                c.disconnect();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    }*/

    /*
    public void showTree(String ex_name){
        cpprofilerbridge.Connector c = new cpprofilerbridge.Connector();
        // Connect to port 6565 (default for cp-profiler)        
        try {
            c.connect(6565);
            try {
                c.start(ex_name,-1);
                while(nodelist.size() &gt; 0){
                    Node node = nodelist.get(0);
                    c.createNode(node.getid(), node.getpid(), node.getpos(), node.children.size(), node.getStatus()).setNodeLabel(&quot;node: &quot; + node.getid()).setNodeInfo(node.toString()).send();           
                    nodelist.remove(0);
                }
                c.disconnect();
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    }*/

    

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>